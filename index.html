<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="darkreader" content="no">
    <title>五子棋游戏</title>
    <style>
        /* CSS样式部分 */
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f5f5dc;
            margin: 0;
            padding: 20px;
        }

        h1 {
            color: #8B4513;
            margin-bottom: 10px;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(15, 30px);
            grid-template-rows: repeat(15, 30px);
            background-color: #DEB887;
            border: 2px solid #8B4513;
            position: relative;
        }

        .cell {
            width: 30px;
            height: 30px;
            box-sizing: border-box;
            position: relative;
            cursor: pointer;
            touch-action: manipulation;
            /* 禁用双击缩放 */
            -webkit-tap-highlight-color: transparent;
            outline: none;
        }

        .cell::before,
        .cell::after {
            content: '';
            position: absolute;
            background-color: #000;
        }

        .cell::before {
            width: 100%;
            height: 1px;
            top: 50%;
            left: 0;
        }

        .cell::after {
            width: 1px;
            height: 100%;
            left: 50%;
            top: 0;
        }

        .piece {
            position: absolute;
            width: 26px;
            height: 26px;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            z-index: 2;
        }

        .black {
            background: radial-gradient(circle at 30% 30%, #666, #000);
            box-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }

        .white {
            background: radial-gradient(circle at 30% 30%, #fff, #ccc);
            box-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }

        .last-move {
            box-shadow: 0 0 0 2px red;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        button {
            padding: 8px 15px;
            background-color: #8B4513;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            background-color: #A0522D;
        }

        /* 禁用按钮样式 */
        button:disabled {
            background-color: #cccccc;
            color: #888888;
            cursor: not-allowed;
        }

        /* 悔棋按钮锁图标样式 */
        #undo.locked {
            background-image: url('https://img.icons8.com/ios/50/lock--v1.png');
            background-repeat: no-repeat;
            background-position: center;
            background-size: 20px;
            color: transparent;
        }

        /* 移动端适配锁图标 */
        @media screen and (max-width: 768px) {
            #undo.locked {
                background-size: 16px;
            }
        }

        .status-container {
            margin-top: 15px;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 30px;
        }

        .status {
            font-size: 18px;
            color: #8B4513;
            font-weight: bold;
            margin-right: 8px;
        }

        .thinking-indicator {
            display: inline-flex;
            align-items: center;
        }

        .star-point {
            position: absolute;
            width: 6px;
            height: 6px;
            background-color: #000;
            border-radius: 50%;
            z-index: 1;
            pointer-events: none;
        }

        select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #8B4513;
            background-color: white;
        }

        /* 新增响应式样式 */
        @media screen and (max-width: 768px) {
            h1 {
                font-size: 24px;
            }

            .board {
                grid-template-columns: repeat(15, 20px);
                grid-template-rows: repeat(15, 20px);
            }

            .cell {
                width: 20px;
                height: 20px;
            }

            .piece {
                width: 16px;
                height: 16px;
                top: 2px;
                left: 2px;
            }

            .star-point {
                width: 4px;
                height: 4px;
            }

            .controls {
                flex-direction: column;
                gap: 8px;
            }

            button,
            select {
                font-size: 16px;
                padding: 10px;
                min-width: 120px;
            }

            .status {
                font-size: 16px;
            }

            .status-container {
                height: 26px;
            }
        }

        .cell:active {
            background-color: transparent;
        }

        /* 思考指示器样式 */
        .thinking-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #8B4513;
            margin: 0 2px;
            opacity: 0.5;
        }

        .thinking-dot:nth-child(1) {
            animation: pulse 1.2s infinite;
        }

        .thinking-dot:nth-child(2) {
            animation: pulse 1.2s infinite 0.4s;
        }

        .thinking-dot:nth-child(3) {
            animation: pulse 1.2s infinite 0.8s;
        }

        @keyframes pulse {
            0%,
            100% {
                transform: scale(1);
                opacity: 0.5;
            }

            50% {
                transform: scale(1.3);
                opacity: 1;
            }
        }

        /* 移动端调整 */
        @media screen and (max-width: 768px) {
            .thinking-dot {
                width: 6px;
                height: 6px;
            }
        }

        /* 音频控制 */
        .audio-controls {
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* 新增: 背景音乐容器样式 */
        .bgm-container {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 100;
        }

        /* 背景音乐按钮样式 */
        .bgm-button {
            background-color: rgba(139, 69, 19, 0.7);
            transition: background-color 0.3s;
            padding: 8px 15px;
            background-color: #8B4513;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .bgm-button:hover {
            background-color: rgba(160, 82, 45, 0.8);
        }

        .bgm-button.off {
            background-color: rgba(139, 69, 19, 0.4);
            color: rgba(255, 255, 255, 0.7);
        }
    </style>
</head>

<body data-darkreader-mode="dynamic" data-darkreader-scheme="disable">
    <h1>五子棋游戏</h1>
    <div class="game-container">
        <!-- 修改后的HTML结构 -->
        <div class="status-container">
            <div class="status">黑方回合</div>
            <div class="thinking-indicator" id="thinking-indicator" style="display: none;">
                <span class="thinking-dot"></span>
                <span class="thinking-dot"></span>
                <span class="thinking-dot"></span>
            </div>
        </div>
        <div class="board" id="board"></div>
        <!-- 修改controls div，添加背景音乐控制按钮 -->
        <div class="controls">
            <button id="restart">重新开始</button>
            <button id="ai-toggle">AI对战: 开启</button>
            <select id="difficulty">
                <option value="easy">简单</option>
                <option value="medium" selected>普通</option>
                <option value="hard">困难</option>
            <option value="insane">疯狂</option>
        </select>
        <button id="undo">悔棋</button> <!-- 添加悔棋按钮 -->
    </div>
</div>
    <!-- 背景音乐控制按钮 -->
    <div class="bgm-container">
        <button id="bgm-toggle" class="bgm-button">背景音乐: 开启</button>
    </div>
    <!-- 添加音频元素 -->
    <audio id="click-sound" src="https://github.com/dreamhartley/gomoku-game/raw/refs/heads/main/sounds/click.wav" preload="auto"></audio>
    <audio id="background-music" src="https://github.com/dreamhartley/gomoku-game/raw/refs/heads/main/sounds/BoardGames.mp3" loop preload="auto"></audio>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // 常量定义
            const BOARD_SIZE = 15;
            const EMPTY = 0;
            const BLACK = 1;
            const WHITE = 2;

                    // 棋型评分
                    const SCORES = {
                        FIVE: 100000,
                        FOUR: 10000,
                        OPEN_FOUR: 15000,     // 活四
                        THREE: 1000,
                        OPEN_THREE: 6000,     // 进一步提高活三评分
                        TWO: 100,
                        ONE: 10,
                        BLOCKED_FOUR: 2500,   // 提高阻塞四的权重以加强防守
                        BLOCKED_THREE: 800,   // 大幅提高阻塞三的权重以加强防守
                        BLOCKED_TWO: 50,      // 增加阻塞二的权重
                        DOUBLE_THREE: 18000,  // 极大提高双三组合威胁值
                        TRIPLE_THREE: 50000,  // 新增：三活三组合，几乎必胜形态
                        FOUR_THREE: 40000,    // 进一步提高四三组合威胁
                        DOUBLE_TWO: 1200,     // 提高双活二评分
                        MULTI_DIRECTION: 8000 // 提高多方向威胁加成，特别是对角线方向
                    };

            // 游戏状态变量
            let board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(EMPTY));
            let currentPlayer = BLACK;
            let gameOver = false;
            let aiEnabled = true;
            let lastMove = null;
            let difficulty = 'medium';
            let backgroundMusicStarted = false;
            let isAITurn = false; // 新增：AI 回合标志
            let moveHistory = []; // 新增：存储落子历史
            let canUndo = true; // 新增：控制是否可以悔棋

            // DOM元素引用
            const boardElement = document.getElementById('board');
            const statusElement = document.querySelector('.status');
            const restartButton = document.getElementById('restart');
            const aiToggleButton = document.getElementById('ai-toggle');
            const difficultySelect = document.getElementById('difficulty');
            const thinkingIndicator = document.getElementById('thinking-indicator');
            const undoButton = document.getElementById('undo'); // 新增：悔棋按钮引用

            // 音效元素
            const clickSound = document.getElementById('click-sound');
            const backgroundMusic = document.getElementById('background-music');
            const bgmToggleButton = document.getElementById('bgm-toggle');

            // 设置背景音乐音量
            backgroundMusic.volume = 0.3;

            // 背景音乐控制函数
            function toggleBackgroundMusic() {
                if (backgroundMusic.paused) {
                    // 如果当前是暂停状态，则播放
                    backgroundMusic.play().catch(e => console.log("背景音乐播放失败:", e));
                    bgmToggleButton.textContent = "背景音乐: 开启";
                    bgmToggleButton.classList.remove('off');
                } else {
                    // 如果当前是播放状态，则暂停
                    backgroundMusic.pause();
                    bgmToggleButton.textContent = "背景音乐: 关闭";
                    bgmToggleButton.classList.add('off');
                }
            }

            // 添加点击事件监听
            bgmToggleButton.addEventListener('click', toggleBackgroundMusic);

            // 修改播放落子音效函数
            function playClickSound() {
                // 重置音效以便能够连续播放
                clickSound.currentTime = 0;
                clickSound.play().catch(e => console.log("音效播放失败:", e));

                // 如果背景音乐还没开始，且按钮不是关闭状态，则开始播放
                if (!backgroundMusicStarted && !bgmToggleButton.classList.contains('off')) {
                    backgroundMusic.play().catch(e => console.log("背景音乐播放失败:", e));
                    backgroundMusicStarted = true;
                }
            }

            // 初始化棋盘
            function initializeBoard() {
                boardElement.innerHTML = '';

                // 创建棋盘格子
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;

                        // 解决问题2：改进触摸事件处理，使用事件代理方式
                        cell.addEventListener('click', (e) => {
                            e.preventDefault(); // 阻止默认行为
                            handleCellClick(row, col);
                        });

                        // 优化触摸事件处理
                        cell.addEventListener('touchstart', (e) => {
                            e.preventDefault(); // 阻止默认触摸行为
                            // 不立即调用handleCellClick，改用touchend事件
                        }, { passive: false });

                        cell.addEventListener('touchend', (e) => {
                            e.preventDefault();
                            // 判断触摸点是否在单元格内
                            const touchX = e.changedTouches[0].clientX;
                            const touchY = e.changedTouches[0].clientY;
                            const rect = cell.getBoundingClientRect();

                            // 扩大判断范围，增加容错度
                            const expandedRect = {
                                left: rect.left - 5,
                                right: rect.right + 5,
                                top: rect.top - 5,
                                bottom: rect.bottom + 5
                            };

                            if (touchX >= expandedRect.left && touchX <= expandedRect.right &&
                                touchY >= expandedRect.top && touchY <= expandedRect.bottom) {
                                handleCellClick(row, col);
                            }
                        }, { passive: false });

                        boardElement.appendChild(cell);
                    }
                }

                // 添加星位标记 - 修改后的部分
                const starPoints = [
                    [3, 3], [3, 11], [7, 7], [11, 3], [11, 11]
                ];

                // 使用当前cell的实际尺寸计算星位位置
                const cells = document.querySelectorAll('.cell');
                if (cells.length > 0) {
                    const firstCell = cells[0];
                    const cellSize = firstCell.offsetWidth;
                    const starSize = window.innerWidth <= 768 ? 4 : 6;
                    const starOffset = (cellSize - starSize) / 2;

                    starPoints.forEach(([row, col]) => {
                        const star = document.createElement('div');
                        star.className = 'star-point';
                        star.style.width = `${starSize}px`;
                        star.style.height = `${starSize}px`;
                        star.style.left = `${col * cellSize + starOffset}px`;
                        star.style.top = `${row * cellSize + starOffset}px`;
                        boardElement.appendChild(star);
                    });
                }
            }

            // 窗口大小改变时重新计算星位位置
            window.addEventListener('resize', function () {
                const stars = document.querySelectorAll('.star-point');
                stars.forEach(star => star.remove());

                const cells = document.querySelectorAll('.cell');
                if (cells.length > 0) {
                    const firstCell = cells[0];
                    const cellSize = firstCell.offsetWidth;
                    const starSize = window.innerWidth <= 768 ? 4 : 6;
                    const starOffset = (cellSize - starSize) / 2;

                    const starPoints = [
                        [3, 3], [3, 11], [7, 7], [11, 3], [11, 11]
                    ];

                    starPoints.forEach(([row, col]) => {
                        const star = document.createElement('div');
                        star.className = 'star-point';
                        star.style.width = `${starSize}px`;
                        star.style.height = `${starSize}px`;
                        star.style.left = `${col * cellSize + starOffset}px`;
                        star.style.top = `${row * cellSize + starOffset}px`;
                        boardElement.appendChild(star);
                    });
                }
            });

            // 处理点击事件
            function handleCellClick(row, col) {
                // 增加判断：如果是 AI 回合，则直接返回
                if (isAITurn || gameOver || board[row][col] !== EMPTY) return;

                // 确保没有任何缓存的点击事件在AI回合后执行
                if (currentPlayer !== BLACK) return;

                // 玩家下棋
                makeMove(row, col, currentPlayer);

                // 播放落子音效
                playClickSound();

                // 检查游戏是否结束
                if (checkWin(row, col, currentPlayer)) {
                    gameOver = true;
                    const winner = currentPlayer === BLACK ? '黑方' : '白方';
                    statusElement.textContent = `${winner}获胜!`;
                    updateUndoButtonState(true); // 游戏结束，禁用悔棋
                    return;
                }

                // 切换玩家
                currentPlayer = currentPlayer === BLACK ? WHITE : BLACK;
                statusElement.textContent = currentPlayer === BLACK ? '黑方回合' : '白方回合';

                // 如果是AI回合且AI开启
                if (aiEnabled && currentPlayer === WHITE && !gameOver) {
                // 设置 AI 回合标志为 true
                isAITurn = true;
                updateUndoButtonState(true); // 禁用悔棋按钮

                // 显示思考指示器
                thinkingIndicator.style.display = 'inline-block';

                    // 根据难度设置延迟时间(优化后的时间范围)
                    let delay;
                    switch(difficulty) {
                        case 'easy':
                            delay = 200 + Math.random() * 600; // 0.2-0.8秒
                            break;
                        case 'medium':
                            delay = 400 + Math.random() * 800; // 0.4-1.2秒
                            break;
                        case 'hard':
                            delay = 800 + Math.random() * 1000; // 0.8-1.8秒
                            break;
                        case 'insane':
                            delay = 200 + Math.random() * 300; // 降低随机延迟，Worker已经在后台处理
                            break;
                        default:
                            delay = 400 + Math.random() * 800;
                    }

                    setTimeout(async () => {
                        try {
                            // 获取AI下棋位置（异步方式）
                            let aiMove;
                            if (difficulty === 'insane') {
                                // 疯狂难度使用Web Worker异步计算
                                aiMove = await findInsaneMove();
                            } else {
                                // 其他难度仍使用同步方式
                                aiMove = findBestMove();
                            }
                            
                            const [aiRow, aiCol] = aiMove;
                            makeMove(aiRow, aiCol, WHITE);

                            // 播放落子音效
                            playClickSound();

                            // 隐藏思考指示器
                            thinkingIndicator.style.display = 'none';

                            if (checkWin(aiRow, aiCol, WHITE)) {
                                gameOver = true;
                                statusElement.textContent = 'AI(白方)获胜!';
                                updateUndoButtonState(true); // 游戏结束，禁用悔棋

                                // 移除 AI 回合标志
                                isAITurn = false;
                                return;
                            }

                            currentPlayer = BLACK;
                            statusElement.textContent = '黑方回合';
                        } catch (error) {
                            console.error('AI决策出错:', error);
                            // 出错时恢复游戏状态
                            thinkingIndicator.style.display = 'none';
                            currentPlayer = BLACK;
                            statusElement.textContent = '黑方回合';
                        } finally {
                            // 无论如何，确保AI回合标志被重置
                            isAITurn = false;
                            updateUndoButtonState(false); // 启用悔棋按钮
                        }
                    }, delay);
                }
            }

            // 下棋
            function makeMove(row, col, player) {
                board[row][col] = player;
                moveHistory.push({ row, col, player }); // 记录历史
                renderPiece(row, col, player);
                lastMove = [row, col];
                canUndo = true; // 落子后允许悔棋
                // 游戏开始后启用悔棋按钮
                if (moveHistory.length > 0) {
                    updateUndoButtonState(false);
                }
            }

            // 移除棋子（用于悔棋）
            function removePiece(row, col) {
                const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                const piece = cell.querySelector('.piece');
                if (piece) {
                    cell.removeChild(piece);
                }
                // 移除可能存在的 last-move 标记
                const lastMovePiece = document.querySelector('.last-move');
                if (lastMovePiece && lastMovePiece.parentElement === cell) {
                    lastMovePiece.classList.remove('last-move');
                }
            }

            // 渲染棋子
            function renderPiece(row, col, player) {
                // 清除上一个移动的标记
                document.querySelectorAll('.last-move').forEach(el => {
                    el.classList.remove('last-move');
                });

                const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                const piece = document.createElement('div');
                piece.className = `piece ${player === BLACK ? 'black' : 'white'}`;
                piece.classList.add('last-move');
                cell.appendChild(piece);
            }

            // 检查胜利条件
            function checkWin(row, col, player) {
                const directions = [
                    [0, 1],   // 水平
                    [1, 0],   // 垂直
                    [1, 1],   // 对角线
                    [1, -1]   // 反对角线
                ];

                for (const [dx, dy] of directions) {
                    let count = 1;

                    // 正向检查
                    for (let i = 1; i < 5; i++) {
                        const r = row + i * dx;
                        const c = col + i * dy;

                        if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE || board[r][c] !== player) break;
                        count++;
                    }

                    // 反向检查
                    for (let i = 1; i < 5; i++) {
                        const r = row - i * dx;
                        const c = col - i * dy;

                        if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE || board[r][c] !== player) break;
                        count++;
                    }

                    if (count >= 5) return true;
                }

                return false;
            }

            // AI逻辑 - 根据难度选择不同策略
            function findBestMove() {
                switch (difficulty) {
                    case 'easy':
                        return findRandomMove();
                    case 'medium':
                        return findIntermediateMove();
                    case 'hard':
                        return findAdvancedMove();
                    case 'insane':
                        return findInsaneMove();
                    default:
                        return findIntermediateMove();
                }
            }

            // Web Worker URL (使用Blob创建内联worker)
            const createAIWorker = function() {
                const workerCode = `
                    // AI Worker代码
                self.onmessage = function(e) {
                        const { board, difficulty } = e.data;
                        let result;
                        
                        if (difficulty === 'insane') {
                            result = findInsaneMove(board);
                        } else if (difficulty === 'hard') {
                            result = findAdvancedMove(board);
                        } else if (difficulty === 'medium') {
                            result = findIntermediateMove(board);
                        } else {
                            result = findRandomMove(board);
                        }
                        
                        self.postMessage({ move: result });
                    };
                    
                    // 开局库 - 常见开局走法
                    const openingMoves = [
                        {
                            // 空棋盘或只有一个中心点
                            check: function(board) {
                                const pieces = board.flat().filter(cell => cell !== EMPTY).length;
                                return pieces <= 1;
                            },
                            moves: [[7, 7], [6, 6], [8, 8], [6, 8], [8, 6]] // 天元或者附近位置
                        },
                        {
                            // 应对中心开局
                            check: function(board) {
                                return board[7][7] !== EMPTY && 
                                       board.flat().filter(cell => cell !== EMPTY).length === 1;
                            },
                            moves: [[6, 6], [8, 8], [6, 8], [8, 6]]
                        }
                        // 可以继续添加更多开局模式
                    ];

                    // Worker中的常量
                    const BOARD_SIZE = 15;
                    const EMPTY = 0;
                    const BLACK = 1;
                    const WHITE = 2;
                    
                    // 棋型评分
                    const SCORES = {
                        FIVE: 100000,
                        FOUR: 10000,
                        OPEN_FOUR: 15000,     // 活四
                        THREE: 1000,
                        OPEN_THREE: 6000,     // 进一步提高活三评分
                        TWO: 100,
                        ONE: 10,
                        BLOCKED_FOUR: 2500,   // 提高阻塞四的权重以加强防守
                        BLOCKED_THREE: 800,   // 大幅提高阻塞三的权重以加强防守
                        BLOCKED_TWO: 50,      // 增加阻塞二的权重
                        DOUBLE_THREE: 18000,  // 极大提高双三组合威胁值
                        TRIPLE_THREE: 50000,  // 新增：三活三组合，几乎必胜形态
                        FOUR_THREE: 40000,    // 进一步提高四三组合威胁
                        DOUBLE_TWO: 1200,     // 提高双活二评分
                        MULTI_DIRECTION: 8000 // 提高多方向威胁加成，特别是对角线方向
                    };

                    // 疯狂难度 - 优化后的AI算法
                    function findInsaneMove(boardState) {
                        // 拷贝棋盘状态
                        const board = boardState.map(row => [...row]);
                        
                        // 获取棋盘上的棋子数量
                        const pieceCount = board.flat().filter(cell => cell !== EMPTY).length;
                        
                        // 检查开局库
                        if (pieceCount < 5) {
                            for (const opening of openingMoves) {
                                if (opening.check(board)) {
                                    // 从合适的开局走法中随机选择一个
                                    const validMoves = opening.moves.filter(([r, c]) => board[r][c] === EMPTY);
                                    if (validMoves.length > 0) {
                                        return validMoves[Math.floor(Math.random() * validMoves.length)];
                                    }
                                }
                            }
                        }
                        
                        // 检查是否有立即获胜或需要阻止的走法
                        const immediateMove = checkImmediateWinOrBlock(board);
                        if (immediateMove) return immediateMove;

                        let bestScore = -Infinity;
                        let bestMove = [7, 7]; // 默认中心位置
                        
                        // 动态调整搜索深度和时间限制
                        let timeLimit, maxDepth;
                        if (pieceCount < 10) {
                            // 开局阶段
                            timeLimit = 1500;
                            maxDepth = 4;
                        } else if (pieceCount < 30) {
                            // 中盘阶段
                            timeLimit = 2500;
                            maxDepth = 5;
                        } else {
                            // 残局阶段
                            timeLimit = 3000;
                            maxDepth = 6;
                        }
                        
                        const candidates = getSmartCandidateMoves(board);
                        
                        // 创建历史表以优化搜索顺序
                        let historyTable = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
                        
                        // 使用迭代加深搜索和α-β剪枝
                        const startTime = Date.now();
                        let depth = 2; // 初始深度
                        let finalBestMove = bestMove;
                        
                        // 迭代加深搜索
                        while (Date.now() - startTime < timeLimit * 0.8 && depth <= maxDepth) {
                            let currentBestScore = -Infinity;
                            let currentBestMove = bestMove;
                            let alpha = -Infinity;
                            let beta = Infinity;
                            
                            // 根据历史表对候选点排序
                            const sortedCandidates = [...candidates].sort((a, b) => {
                                const [rowA, colA] = a;
                                const [rowB, colB] = b;
                                return historyTable[rowB][colB] - historyTable[rowA][colA];
                            });
                            
                            for (const [row, col] of sortedCandidates) {
                                if (Date.now() - startTime > timeLimit) break;

                                board[row][col] = WHITE;
                                const score = minimax(board, depth - 1, alpha, beta, false, startTime, timeLimit, historyTable);
                                board[row][col] = EMPTY;

                                if (score > currentBestScore) {
                                    currentBestScore = score;
                                    currentBestMove = [row, col];
                                    alpha = Math.max(alpha, score);
                                    
                                    // 更新历史表
                                    historyTable[row][col] += Math.pow(2, depth);
                                }

                                if (beta <= alpha) break; // α-β剪枝
                            }
                            
                            if (currentBestScore > bestScore) {
                                bestScore = currentBestScore;
                                finalBestMove = currentBestMove;
                            }
                            depth++;
                        }

                        return finalBestMove;
                    }
                    
                    // Worker中的其它AI实现...
                    function findRandomMove(boardState) {
                        const board = boardState.map(row => [...row]);
                        
                        // 检查立即获胜或阻挡
                        const immediateMove = checkImmediateWinOrBlock(board);
                        if (immediateMove) return immediateMove;

                        // 基础评分系统
                        const scoredMoves = [];
                        let maxScore = 0;

                        // 遍历所有空位
                        for (let row = 0; row < BOARD_SIZE; row++) {
                            for (let col = 0; col < BOARD_SIZE; col++) {
                                if (board[row][col] === EMPTY) {
                                    let score = 0;
                                    
                                    // 1. 中心区域权重
                                    const centerDist = Math.abs(row - 7) + Math.abs(col - 7);
                                    score += (14 - centerDist) * 3;
                                    
                                    // 2. 邻近已有棋子加分
                                    for (let r = Math.max(0, row-1); r <= Math.min(14, row+1); r++) {
                                        for (let c = Math.max(0, col-1); c <= Math.min(14, col+1); c++) {
                                            if (board[r][c] !== EMPTY) {
                                                score += (board[r][c] === WHITE) ? 5 : 8; // 更注重防守
                                            }
                                        }
                                    }
                                    
                                    // 3. 基础棋型识别
                                    const defendScore = evaluatePosition(board, row, col, BLACK) * 0.6;
                                    const attackScore = evaluatePosition(board, row, col, WHITE) * 0.4;
                                    score += defendScore + attackScore;

                                    // 记录得分和位置
                                    scoredMoves.push({pos: [row, col], score: score});
                                    maxScore = Math.max(maxScore, score);
                                }
                            }
                        }

                        // 从高分位置中随机选择
                        const candidateMoves = scoredMoves.filter(m => m.score >= maxScore * 0.7);
                        if (candidateMoves.length > 0) {
                            return candidateMoves[Math.floor(Math.random() * candidateMoves.length)].pos;
                        }

                        // 保底随机选择
                        return scoredMoves.length > 0 
                            ? scoredMoves[Math.floor(Math.random() * scoredMoves.length)].pos
                            : [7, 7];
                    }

                    function findIntermediateMove(boardState) {
                        const board = boardState.map(row => [...row]);
                        
                        // 检查是否有立即获胜或阻止对手获胜的位置
                        const immediateMove = checkImmediateWinOrBlock(board);
                        if (immediateMove) return immediateMove;

                        // 评分系统选择最佳位置
                        let bestScore = -Infinity;
                        let bestMoves = [];

                        for (let row = 0; row < BOARD_SIZE; row++) {
                            for (let col = 0; col < BOARD_SIZE; col++) {
                                if (board[row][col] === EMPTY) {
                                    // 评估进攻和防守分数
                                    const attackScore = evaluatePosition(board, row, col, WHITE);
                                    const defendScore = evaluatePosition(board, row, col, BLACK) * 0.8; // 防守权重略低
                                    const totalScore = attackScore + defendScore;

                                    // 中心位置加成
                                    const center = (BOARD_SIZE - 1) / 2;
                                    const distanceToCenter = Math.sqrt(Math.pow(row - center, 2) + Math.pow(col - center, 2));
                                    const centerBonus = (BOARD_SIZE - distanceToCenter) / 2;
                                    const finalScore = totalScore + centerBonus;

                                    if (finalScore > bestScore) {
                                        bestScore = finalScore;
                                        bestMoves = [[row, col]];
                                    } else if (finalScore === bestScore) {
                                        bestMoves.push([row, col]);
                                    }
                                }
                            }
                        }

                        // 如果有多个最佳位置，随机选择一个
                        if (bestMoves.length > 0) {
                            return bestMoves[Math.floor(Math.random() * bestMoves.length)];
                        }

                        return [7, 7]; // 默认中心位置
                    }

                    function findAdvancedMove(boardState) {
                        const board = boardState.map(row => [...row]);
                        
                        // 检查是否有立即获胜或需要阻止的走法
                        const immediateMove = checkImmediateWinOrBlock(board);
                        if (immediateMove) return immediateMove;

                        // 使用更复杂的评估和有限搜索
                        let bestScore = -Infinity;
                        let bestMove = [7, 7]; // 默认中心位置
                        const candidates = getCandidateMoves(board);

                        for (const [row, col] of candidates) {
                            board[row][col] = WHITE;

                            // 简单的一层搜索
                            const score = evaluateBoard(board) + (Math.random() * 10); // 添加少量随机性
                            board[row][col] = EMPTY;

                            if (score > bestScore) {
                                bestScore = score;
                                bestMove = [row, col];
                            }
                        }

                        return bestMove;
                    }

                    // 威胁空间搜索 - 识别关键威胁位置
                    function identifyThreats(board, player) {
                        const threats = [];
                        const opponent = player === BLACK ? WHITE : BLACK;
                        
                        // 遍历所有空位
                        for (let row = 0; row < BOARD_SIZE; row++) {
                            for (let col = 0; col < BOARD_SIZE; col++) {
                                if (board[row][col] === EMPTY) {
                                    // 临时落子检查威胁
                                    board[row][col] = player;
                                    
                                    // 检查是否形成四连、活三等威胁
                                    const score = evaluatePosition(board, row, col, player);
                                    if (score >= SCORES.OPEN_THREE) {
                                        threats.push({
                                            pos: [row, col],
                                            score: score,
                                            type: score >= SCORES.FOUR ? 'four' : 'three'
                                        });
                                    }
                                    
                                    board[row][col] = EMPTY;
                                }
                            }
                        }
                        
                        // 按威胁程度排序
                        return threats.sort((a, b) => b.score - a.score);
                    }

                    // 需要的辅助函数
                    function minimax(board, depth, alpha, beta, isMaximizing, startTime, timeLimit, historyTable) {
                        // 检查游戏结束或达到最大深度或超时
                        if (depth === 0 || (startTime && Date.now() - startTime > timeLimit)) {
                            return evaluateBoard(board);
                        }
                        
                        // 检查是否有玩家方的立即获胜点
                        if (!isMaximizing) {
                            for (let row = 0; row < BOARD_SIZE; row++) {
                                for (let col = 0; col < BOARD_SIZE; col++) {
                                    if (board[row][col] === EMPTY) {
                                        board[row][col] = BLACK;
                                        if (checkWin(board, row, col, BLACK)) {
                                            board[row][col] = EMPTY;
                                            return -100000; // 玩家获胜，极低分数
                                        }
                                        board[row][col] = EMPTY;
                                    }
                                }
                            }
                        }
                        
                        // 检查是否有AI方的立即获胜点
                        if (isMaximizing) {
                            for (let row = 0; row < BOARD_SIZE; row++) {
                                for (let col = 0; col < BOARD_SIZE; col++) {
                                    if (board[row][col] === EMPTY) {
                                        board[row][col] = WHITE;
                                        if (checkWin(board, row, col, WHITE)) {
                                            board[row][col] = EMPTY;
                                            return 100000; // AI获胜，极高分数
                                        }
                                        board[row][col] = EMPTY;
                                    }
                                }
                            }
                        }

                        // 识别关键威胁
                        const threats = identifyThreats(board, isMaximizing ? WHITE : BLACK);
                        
                        // 优先考虑威胁位置
                        let candidates;
                        if (threats.length > 0 && threats[0].score >= SCORES.FOUR) {
                            // 如果有高度威胁，只考虑威胁位置
                            candidates = threats.map(t => t.pos);
                        } else {
                            // 否则使用一般候选位置
                            candidates = getCandidateMoves(board);
                            
                            // 使用历史表排序
                            if (historyTable) {
                                candidates.sort((a, b) => {
                                    const [rowA, colA] = a;
                                    const [rowB, colB] = b;
                                    return historyTable[rowB][colB] - historyTable[rowA][colA];
                                });
                            }
                        }

                        if (isMaximizing) {
                            let maxEval = -Infinity;
                            for (const [row, col] of candidates) {
                                board[row][col] = WHITE;
                                const eval = minimax(board, depth - 1, alpha, beta, false, startTime, timeLimit, historyTable);
                                board[row][col] = EMPTY;
                                maxEval = Math.max(maxEval, eval);
                                alpha = Math.max(alpha, eval);
                                
                                // 更新历史表
                                if (historyTable && eval >= beta) {
                                    historyTable[row][col] += Math.pow(2, depth);
                                }
                                
                                if (beta <= alpha) break;
                            }
                            return maxEval;
                        } else {
                            let minEval = Infinity;
                            for (const [row, col] of candidates) {
                                board[row][col] = BLACK;
                                const eval = minimax(board, depth - 1, alpha, beta, true, startTime, timeLimit, historyTable);
                                board[row][col] = EMPTY;
                                minEval = Math.min(minEval, eval);
                                beta = Math.min(beta, eval);
                                
                                // 更新历史表
                                if (historyTable && eval <= alpha) {
                                    historyTable[row][col] += Math.pow(2, depth);
                                }
                                
                                if (beta <= alpha) break;
                            }
                            return minEval;
                        }
                    }

                    function getCandidateMoves(board) {
                        const candidates = [];
                        const range = 2; // 只考虑已有棋子周围2格范围内的位置
                        const occupiedCells = [];

                        // 首先收集所有已有棋子的位置
                        for (let row = 0; row < BOARD_SIZE; row++) {
                            for (let col = 0; col < BOARD_SIZE; col++) {
                                if (board[row][col] !== EMPTY) {
                                    occupiedCells.push([row, col]);
                                }
                            }
                        }

                        // 如果没有棋子，返回中心点
                        if (occupiedCells.length === 0) return [[7, 7]];

                        // 遍历所有已有棋子周围的空位
                        const visited = new Set();
                        for (const [row, col] of occupiedCells) {
                            for (let r = Math.max(0, row - range); r <= Math.min(BOARD_SIZE - 1, row + range); r++) {
                                for (let c = Math.max(0, col - range); c <= Math.min(BOARD_SIZE - 1, col + range); c++) {
                                    if (board[r][c] === EMPTY && !visited.has(\`\${r},\${c}\`)) {
                                        candidates.push([r, c]);
                                        visited.add(\`\${r},\${c}\`);
                                    }
                                }
                            }
                        }

                        // 如果没有候选位置（理论上不会发生），返回中心点
                        return candidates.length > 0 ? candidates : [[7, 7]];
                    }

                    function getSmartCandidateMoves(board) {
                        const candidates = new Set();
                        const center = (BOARD_SIZE - 1) / 2;
                        
                        // 1. 优先考虑已有棋子周围的位置
                        for (let row = 0; row < BOARD_SIZE; row++) {
                            for (let col = 0; col < BOARD_SIZE; col++) {
                                if (board[row][col] !== EMPTY) {
                                    // 动态调整搜索范围 - 根据棋盘上棋子数量
                                    const range = board.flat().filter(c => c !== EMPTY).length < 10 ? 4 : 3;
                                    
                                    // 周围范围内的空位
                                    for (let r = Math.max(0, row - range); r <= Math.min(BOARD_SIZE - 1, row + range); r++) {
                                        for (let c = Math.max(0, col - range); c <= Math.min(BOARD_SIZE - 1, col + range); c++) {
                                            if (board[r][c] === EMPTY) {
                                                candidates.add(\`\${r},\${c}\`);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        // 2. 如果没有棋子，返回中心点
                        if (candidates.size === 0) return [[center, center]];
                        
                        // 3. 按评分排序候选位置
                        const sortedCandidates = Array.from(candidates).map(pos => {
                            const [r, c] = pos.split(',').map(Number);
                            // 优化评分计算: 增加中心位置权重和已有棋型评估
                            const centerWeight = 1 - (Math.abs(r - center) + Math.abs(c - center)) / (2 * center);
                            const attackScore = evaluatePosition(board, r, c, WHITE);
                            const defendScore = evaluatePosition(board, r, c, BLACK) * 1.2; // 增加防守权重，更重视封堵玩家
                            
                            return { 
                                pos: [r, c], 
                                score: attackScore + defendScore + centerWeight * 50 
                            };
                        }).sort((a, b) => b.score - a.score);
                        
                        // 返回前30个最佳候选位置(增加数量提高AI能考虑到的防守点)
                        return sortedCandidates.slice(0, 30).map(item => item.pos);
                    }

                    function checkImmediateWinOrBlock(board) {
                        // 1. 首先检查AI是否有立即获胜的位置
                        for (let row = 0; row < BOARD_SIZE; row++) {
                            for (let col = 0; col < BOARD_SIZE; col++) {
                                if (board[row][col] === EMPTY) {
                                    board[row][col] = WHITE;
                                    if (checkWin(board, row, col, WHITE)) {
                                        board[row][col] = EMPTY;
                                        return [row, col];
                                    }
                                    board[row][col] = EMPTY;
                                }
                            }
                        }

                        // 2. 阻止玩家即将获胜
                        for (let row = 0; row < BOARD_SIZE; row++) {
                            for (let col = 0; col < BOARD_SIZE; col++) {
                                if (board[row][col] === EMPTY) {
                                    board[row][col] = BLACK;
                                    if (checkWin(board, row, col, BLACK)) {
                                        board[row][col] = EMPTY;
                                        return [row, col];
                                    }
                                    board[row][col] = EMPTY;
                                }
                            }
                        }

                        return null;
                    }

                    function checkWin(board, row, col, player) {
                        const directions = [
                            [0, 1],   // 水平
                            [1, 0],   // 垂直
                            [1, 1],   // 对角线
                            [1, -1]   // 反对角线
                        ];

                        for (const [dx, dy] of directions) {
                            let count = 1;

                            // 正向检查
                            for (let i = 1; i < 5; i++) {
                                const r = row + i * dx;
                                const c = col + i * dy;

                                if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE || board[r][c] !== player) break;
                                count++;
                            }

                            // 反向检查
                            for (let i = 1; i < 5; i++) {
                                const r = row - i * dx;
                                const c = col - i * dy;

                                if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE || board[r][c] !== player) break;
                                count++;
                            }

                            if (count >= 5) return true;
                        }

                        return false;
                    }

                    function evaluatePosition(board, row, col, player) {
                        let score = 0;
                        const directions = [
                            [0, 1],   // 水平
                            [1, 0],   // 垂直
                            [1, 1],   // 对角线
                            [1, -1]   // 反对角线
                        ];
                        
                        // 跟踪各种棋型的数量，用于识别复合棋型
                        let openThreeCount = 0;
                        let openFourCount = 0;
                        let fourCount = 0;
                        let twoCount = 0;
                        let blockedThreeCount = 0;

                        for (const [dx, dy] of directions) {
                            // 扩大检查范围到9个位置，更好地识别连续棋型
                            let sequence = '';

                            for (let i = -4; i <= 4; i++) {
                                const r = row + i * dx;
                                const c = col + i * dy;

                                if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) {
                                    sequence += 'x'; // 边界
                                } else if (board[r][c] === EMPTY) {
                                    sequence += '0';
                                } else if (board[r][c] === player) {
                                    sequence += '1';
                                } else {
                                    sequence += '2'; // 对手棋子
                                }
                            }

                            // 增强棋型识别的模式和评分
                            const patterns = [
                                { regex: /11111/, score: SCORES.FIVE, type: 'FIVE' }, // 五连
                                
                                // 活四和各种变形
                                { regex: /011110/, score: SCORES.OPEN_FOUR, type: 'OPEN_FOUR' }, // 活四
                                
                                // 各种冲四形态
                                { regex: /011112|211110/, score: SCORES.BLOCKED_FOUR, type: 'BLOCKED_FOUR' }, // 冲四（单边封堵）
                                { regex: /0111010|0101110/, score: SCORES.BLOCKED_FOUR, type: 'BLOCKED_FOUR' }, // 特殊冲四形态
                                { regex: /10111|11011|11101/, score: SCORES.BLOCKED_FOUR, type: 'BLOCKED_FOUR' }, // 跳四
                                { regex: /011101|101110/, score: SCORES.BLOCKED_FOUR, type: 'BLOCKED_FOUR' }, // 新增：另一种特殊冲四形态
                                
                        // 活三和各种变形
                        { regex: /01110/, score: SCORES.OPEN_THREE, type: 'OPEN_THREE' }, // 标准活三
                        { regex: /011010|010110/, score: SCORES.OPEN_THREE * 0.9, type: 'OPEN_THREE' }, // 次级活三形态
                        { regex: /0110100/, score: SCORES.OPEN_THREE * 0.8, type: 'OPEN_THREE' }, // 新增：间隔活三变种
                        
                        // 跳三变种 - 增强对跳三的识别
                        { regex: /010110|011010/, score: SCORES.OPEN_THREE * 0.95, type: 'OPEN_THREE' }, // 跳三形态1: ● _ ● ●
                        { regex: /01101|10110/, score: SCORES.OPEN_THREE * 0.9, type: 'OPEN_THREE' }, // 跳三形态2: ● ● _ ●
                        { regex: /0101010/, score: SCORES.OPEN_THREE * 0.85, type: 'OPEN_THREE' }, // 特殊跳三: ● _ ● _ ●
                        
                        // 眠三变种
                        { regex: /211100|001112/, score: SCORES.BLOCKED_THREE, type: 'BLOCKED_THREE' }, // 眠三(一侧被堵)
                        { regex: /10011|11001/, score: SCORES.BLOCKED_THREE, type: 'BLOCKED_THREE' }, // 眠三(跳型)
                        { regex: /21110|01112/, score: SCORES.BLOCKED_THREE * 0.9, type: 'BLOCKED_THREE' }, // 新增：边缘眠三
                        { regex: /10101/, score: SCORES.BLOCKED_THREE * 0.8, type: 'BLOCKED_THREE' }, // 新增：间隔眠三
                        { regex: /210110|011012/, score: SCORES.BLOCKED_THREE * 0.85, type: 'BLOCKED_THREE' }, // 新增：跳三被堵
                                
                                // 活二变种
                                { regex: /00110|01100/, score: SCORES.TWO, type: 'TWO' }, // 活二
                                { regex: /01010/, score: SCORES.TWO, type: 'TWO' }, // 跳活二
                                { regex: /010010/, score: SCORES.TWO * 0.8, type: 'TWO' }, // 间隔活二
                                
                                // 眠二变种
                                { regex: /211000|000112/, score: SCORES.BLOCKED_TWO, type: 'BLOCKED_TWO' }, // 眠二(一侧被堵)
                                { regex: /210100|001012/, score: SCORES.BLOCKED_TWO, type: 'BLOCKED_TWO' }, // 眠二(跳型)
                                { regex: /21010|01012/, score: SCORES.BLOCKED_TWO * 0.8, type: 'BLOCKED_TWO' }, // 边缘眠二
                                
                                // 活一
                                { regex: /00010|01000/, score: SCORES.ONE, type: 'ONE' } // 活一
                            ];

                            for (const pattern of patterns) {
                                if (pattern.regex.test(sequence)) {
                                    score += pattern.score;
                                    
                                    // 跟踪各类型棋型的数量
                                    if (pattern.type === 'OPEN_THREE') openThreeCount++;
                                    if (pattern.type === 'BLOCKED_THREE') blockedThreeCount++;
                                    if (pattern.type === 'OPEN_FOUR') openFourCount++;
                                    if (pattern.type === 'BLOCKED_FOUR' || pattern.type === 'OPEN_FOUR') fourCount++;
                                    if (pattern.type === 'TWO') twoCount++;
                                    
                                    break;
                                }
                            }
                        }
                        
                        // 复合棋型的额外评分（大幅增强）
                        if (openThreeCount >= 2) {
                            score += SCORES.DOUBLE_THREE; // 双活三，强力攻击形态
                        } else if (openThreeCount >= 1 && blockedThreeCount >= 1) {
                            // 新增：活三+眠三组合
                            score += SCORES.DOUBLE_THREE * 0.7;
                        }
                        
                        if (openThreeCount >= 1 && fourCount >= 1) {
                            score += SCORES.FOUR_THREE; // 四三组合，几乎必胜形态
                        }
                        
                        if (twoCount >= 2) {
                            score += SCORES.DOUBLE_TWO; // 双活二组合
                        }
                        
                        // 根据棋子的数量动态调整分数
                        const totalPieces = board.flat().filter(cell => cell !== EMPTY).length;
                        
                        // 在残局阶段，更重视进攻
                        if (totalPieces > 30) {
                            score *= 1.2;
                        } else if (totalPieces < 10) {
                            // 在开局阶段，更注重布局和防守
                            const center = (BOARD_SIZE - 1) / 2;
                            const distanceToCenter = Math.abs(row - center) + Math.abs(col - center);
                            score += (14 - distanceToCenter) * 3; // 中心加分
                        }

                        return score;
                    }

                    function evaluateBoard(board) {
                        let score = 0;
                        let playerMaxThreat = 0;
                        let aiMaxThreat = 0;

                        // 评估白棋（AI）的优势
                        for (let row = 0; row < BOARD_SIZE; row++) {
                            for (let col = 0; col < BOARD_SIZE; col++) {
                                if (board[row][col] === WHITE) {
                                    const pieceScore = evaluatePosition(board, row, col, WHITE);
                                    score += pieceScore;
                                    aiMaxThreat = Math.max(aiMaxThreat, pieceScore);
                                } else if (board[row][col] === BLACK) {
                                    const pieceScore = evaluatePosition(board, row, col, BLACK);
                                    playerMaxThreat = Math.max(playerMaxThreat, pieceScore);
                                    
                                    // 使用动态权重，对危险棋型增加更高防守权重
                                    let defensiveFactor = 2.0; // 提高基础防守权重
                                    
                                    // 根据威胁级别调整防守权重
                                    if (pieceScore >= SCORES.OPEN_THREE) defensiveFactor = 2.8;
                                    if (pieceScore >= SCORES.BLOCKED_FOUR) defensiveFactor = 3.2;
                                    if (pieceScore >= SCORES.OPEN_FOUR || pieceScore >= SCORES.DOUBLE_THREE) defensiveFactor = 3.8; 
                                    if (pieceScore >= SCORES.FOUR_THREE) defensiveFactor = 4.5;
                                    
                                    score -= pieceScore * defensiveFactor;
                                }
                            }
                        }
                        
                        // 额外战术考量：如果玩家有威胁，提高防守优先级
                        // 修改：降低威胁等级门槛，提高防守系数
                        if (playerMaxThreat >= SCORES.OPEN_THREE && aiMaxThreat < SCORES.FIVE) {
                            score -= playerMaxThreat * 4; // 更强的防守优先级
                        }
                        
                        // 特别关注对角线威胁
                        const diagonalThreat = checkDiagonalThreats(board, BLACK);
                        if (diagonalThreat > 0) {
                            score -= diagonalThreat * 2.5; // 额外的对角线防守权重
                        }

                        // 检测对角线威胁的函数
                        function checkDiagonalThreats(board, player) {
                            let maxThreat = 0;
                            const diagonalDirections = [
                                [1, 1],   // 对角线
                                [1, -1]   // 反对角线
                            ];
                            
                            // 遍历棋盘寻找对角线威胁
                            for (let row = 0; row < BOARD_SIZE; row++) {
                                for (let col = 0; col < BOARD_SIZE; col++) {
                                    if (board[row][col] === player) {
                                        // 检查每个对角线方向
                                        for (const [dx, dy] of diagonalDirections) {
                                            let threatScore = evaluateDiagonalThreat(board, row, col, dx, dy, player);
                                            maxThreat = Math.max(maxThreat, threatScore);
                                        }
                                    }
                                }
                            }
                            
                            return maxThreat;
                        }
                        
                        // 评估特定方向的对角线威胁
                        function evaluateDiagonalThreat(board, row, col, dx, dy, player) {
                            // 计算连续棋子数
                            let count = 1;
                            let openEnds = 0;
                            
                            // 正向检查
                            for (let i = 1; i < 5; i++) {
                                const r = row + i * dx;
                                const c = col + i * dy;
                                
                                if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) break;
                                
                                if (board[r][c] === player) {
                                    count++;
                                } else if (board[r][c] === EMPTY) {
                                    openEnds++;
                                    break;
                                } else {
                                    break;
                                }
                            }
                            
                            // 反向检查
                            for (let i = 1; i < 5; i++) {
                                const r = row - i * dx;
                                const c = col - i * dy;
                                
                                if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) break;
                                
                                if (board[r][c] === player) {
                                    count++;
                                } else if (board[r][c] === EMPTY) {
                                    openEnds++;
                                    break;
                                } else {
                                    break;
                                }
                            }
                            
                            // 根据连续棋子数和开放端数评估威胁
                            if (count >= 4) {
                                return openEnds > 0 ? SCORES.BLOCKED_FOUR * 1.5 : SCORES.BLOCKED_FOUR;
                            } else if (count == 3) {
                                return openEnds == 2 ? SCORES.OPEN_THREE * 1.2 : (openEnds == 1 ? SCORES.BLOCKED_THREE * 1.2 : 0);
                            } else if (count == 2) {
                                return openEnds == 2 ? SCORES.TWO * 1.2 : (openEnds == 1 ? SCORES.BLOCKED_TWO * 1.2 : 0);
                            }
                            
                            return 0;
                        }
                        
                        // 鼓励进攻性下法，特别是在有优势时
                        if (aiMaxThreat > playerMaxThreat && aiMaxThreat >= SCORES.OPEN_THREE) {
                            score += aiMaxThreat * 0.5; // 进攻加成
                        }

                        return score;
                    }
                `;
                
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                return new Worker(URL.createObjectURL(blob));
            };
            
            // 使用Worker处理AI决策
            let aiWorker = null;

            // 疯狂难度 - 使用Worker优化的AI算法
            function findInsaneMove() {
                return new Promise((resolve) => {
                    // 检查是否有立即获胜或需要阻止的走法（快速检查在主线程完成）
                    const immediateMove = checkImmediateWinOrBlock();
                    if (immediateMove) {
                        resolve(immediateMove);
                        return;
                    }
                    
                    // 创建或重用Worker
                    if (!aiWorker) {
                        aiWorker = createAIWorker();
                    }
                    
                    // 设置回调
                    aiWorker.onmessage = function(e) {
                        const result = e.data.move;
                        resolve(result);
                    };
                    
                    // 发送数据到Worker
                    aiWorker.postMessage({
                        board: board,
                        difficulty: 'insane'
                    });
                });
            }

            // 更智能的候选位置生成
            function getSmartCandidateMoves() {
                const candidates = new Set();
                const center = (BOARD_SIZE - 1) / 2;
                
                // 1. 优先考虑已有棋子周围的位置
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (board[row][col] !== EMPTY) {
                            // 动态调整搜索范围 - 根据棋盘上棋子数量
                            const range = board.flat().filter(c => c !== EMPTY).length < 10 ? 4 : 3;
                            
                            // 周围范围内的空位
                            for (let r = Math.max(0, row - range); r <= Math.min(BOARD_SIZE - 1, row + range); r++) {
                                for (let c = Math.max(0, col - range); c <= Math.min(BOARD_SIZE - 1, col + range); c++) {
                                    if (board[r][c] === EMPTY) {
                                        candidates.add(`${r},${c}`);
                                    }
                                }
                            }
                        }
                    }
                }
                
                // 2. 如果没有棋子，返回中心点
                if (candidates.size === 0) return [[center, center]];
                
                // 3. 按评分排序候选位置
                const sortedCandidates = Array.from(candidates).map(pos => {
                    const [r, c] = pos.split(',').map(Number);
                    // 优化评分计算: 增加中心位置权重和已有棋型评估
                    const centerWeight = 1 - (Math.abs(r - center) + Math.abs(c - center)) / (2 * center);
                    const attackScore = evaluatePosition(r, c, WHITE);
                    const defendScore = evaluatePosition(r, c, BLACK) * 1.2; // 增加防守权重，更重视封堵玩家
                    
                    return { 
                        pos: [r, c], 
                        score: attackScore + defendScore + centerWeight * 50 
                    };
                }).sort((a, b) => b.score - a.score);
                
                        // 返回前30个最佳候选位置(增加数量提高AI能考虑到的防守点)
                        return sortedCandidates.slice(0, 30).map(item => item.pos);
            }

            // 优化后的Minimax算法
            function minimax(depth, alpha, beta, isMaximizing, startTime, timeLimit) {
                // 检查游戏结束或达到最大深度或超时
                if (depth === 0 || gameOver || (startTime && Date.now() - startTime > timeLimit)) {
                    return evaluateBoard();
                }

                const candidates = getCandidateMoves();

                if (isMaximizing) {
                    let maxEval = -Infinity;
                    for (const [row, col] of candidates) {
                        board[row][col] = WHITE;
                        const eval = minimax(depth - 1, alpha, beta, false, startTime, timeLimit);
                        board[row][col] = EMPTY;
                        maxEval = Math.max(maxEval, eval);
                        alpha = Math.max(alpha, eval);
                        if (beta <= alpha) break;
                    }
                    return maxEval;
                } else {
                    let minEval = Infinity;
                    for (const [row, col] of candidates) {
                        board[row][col] = BLACK;
                        const eval = minimax(depth - 1, alpha, beta, true, startTime, timeLimit);
                        board[row][col] = EMPTY;
                        minEval = Math.min(minEval, eval);
                        beta = Math.min(beta, eval);
                        if (beta <= alpha) break;
                    }
                    return minEval;
                }
            }

            // 简单难度 - 增强版随机走棋
            function findRandomMove() {
                // 检查立即获胜或阻挡
                const immediateMove = checkImmediateWinOrBlock();
                if (immediateMove) return immediateMove;

                // 基础评分系统
                const scoredMoves = [];
                let maxScore = 0;

                // 遍历所有空位
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (board[row][col] === EMPTY) {
                            let score = 0;
                            
                            // 1. 中心区域权重
                            const centerDist = Math.abs(row - 7) + Math.abs(col - 7);
                            score += (14 - centerDist) * 3;
                            
                            // 2. 邻近已有棋子加分
                            for (let r = Math.max(0, row-1); r <= Math.min(14, row+1); r++) {
                                for (let c = Math.max(0, col-1); c <= Math.min(14, col+1); c++) {
                                    if (board[r][c] !== EMPTY) {
                                        score += (board[r][c] === WHITE) ? 5 : 8; // 更注重防守
                                    }
                                }
                            }
                            
                            // 3. 基础棋型识别
                            const defendScore = evaluatePosition(row, col, BLACK) * 0.6;
                            const attackScore = evaluatePosition(row, col, WHITE) * 0.4;
                            score += defendScore + attackScore;

                            // 记录得分和位置
                            scoredMoves.push({pos: [row, col], score: score});
                            maxScore = Math.max(maxScore, score);
                        }
                    }
                }

                // 从高分位置中随机选择
                const candidateMoves = scoredMoves.filter(m => m.score >= maxScore * 0.7);
                if (candidateMoves.length > 0) {
                    return candidateMoves[Math.floor(Math.random() * candidateMoves.length)].pos;
                }

                // 保底随机选择
                return scoredMoves.length > 0 
                    ? scoredMoves[Math.floor(Math.random() * scoredMoves.length)].pos
                    : [7, 7];
            }

            // 中等难度 - 使用评分系统
            function findIntermediateMove() {
                // 检查是否有立即获胜或阻止对手获胜的位置
                const immediateMove = checkImmediateWinOrBlock();
                if (immediateMove) return immediateMove;

                // 评分系统选择最佳位置
                let bestScore = -Infinity;
                let bestMoves = [];

                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (board[row][col] === EMPTY) {
                            // 评估进攻和防守分数
                            const attackScore = evaluatePosition(row, col, WHITE);
                            const defendScore = evaluatePosition(row, col, BLACK) * 0.8; // 防守权重略低
                            const totalScore = attackScore + defendScore;

                            // 中心位置加成
                            const center = (BOARD_SIZE - 1) / 2;
                            const distanceToCenter = Math.sqrt(Math.pow(row - center, 2) + Math.pow(col - center, 2));
                            const centerBonus = (BOARD_SIZE - distanceToCenter) / 2;
                            const finalScore = totalScore + centerBonus;

                            if (finalScore > bestScore) {
                                bestScore = finalScore;
                                bestMoves = [[row, col]];
                            } else if (finalScore === bestScore) {
                                bestMoves.push([row, col]);
                            }
                        }
                    }
                }

                // 如果有多个最佳位置，随机选择一个
                if (bestMoves.length > 0) {
                    return bestMoves[Math.floor(Math.random() * bestMoves.length)];
                }

                return [7, 7]; // 默认中心位置
            }

            // 困难难度 - 使用更复杂的评估和有限搜索
            function findAdvancedMove() {
                // 检查是否有立即获胜或需要阻止的走法
                const immediateMove = checkImmediateWinOrBlock();
                if (immediateMove) return immediateMove;

                // 使用更复杂的评估和有限搜索
                let bestScore = -Infinity;
                let bestMove = [7, 7]; // 默认中心位置
                const candidates = getCandidateMoves();

                for (const [row, col] of candidates) {
                    board[row][col] = WHITE;

                    // 简单的一层搜索
                    const score = evaluateBoard() + (Math.random() * 10); // 添加少量随机性
                    board[row][col] = EMPTY;

                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = [row, col];
                    }
                }

                return bestMove;
            }

            // 保留原getCandidateMoves函数供其他难度使用
            function getCandidateMoves() {
                const candidates = [];
                const range = 2; // 只考虑已有棋子周围2格范围内的位置
                const occupiedCells = [];

                // 首先收集所有已有棋子的位置
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (board[row][col] !== EMPTY) {
                            occupiedCells.push([row, col]);
                        }
                    }
                }

                // 如果没有棋子，返回中心点
                if (occupiedCells.length === 0) return [[7, 7]];

                // 遍历所有已有棋子周围的空位
                const visited = new Set();
                for (const [row, col] of occupiedCells) {
                    for (let r = Math.max(0, row - range); r <= Math.min(BOARD_SIZE - 1, row + range); r++) {
                        for (let c = Math.max(0, col - range); c <= Math.min(BOARD_SIZE - 1, col + range); c++) {
                            if (board[r][c] === EMPTY && !visited.has(`${r},${c}`)) {
                                candidates.push([r, c]);
                                visited.add(`${r},${c}`);
                            }
                        }
                    }
                }

                // 如果没有候选位置（理论上不会发生），返回中心点
                return candidates.length > 0 ? candidates : [[7, 7]];
            }

            // 检查是否有立即获胜或需要阻止的走法
            function checkImmediateWinOrBlock() {
                // 1. 首先检查AI是否有立即获胜的位置
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (board[row][col] === EMPTY) {
                            board[row][col] = WHITE;
                            if (checkWin(row, col, WHITE)) {
                                board[row][col] = EMPTY;
                                return [row, col];
                            }
                            board[row][col] = EMPTY;
                        }
                    }
                }

                // 2. 阻止玩家即将获胜
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (board[row][col] === EMPTY) {
                            board[row][col] = BLACK;
                            if (checkWin(row, col, BLACK)) {
                                board[row][col] = EMPTY;
                                return [row, col];
                            }
                            board[row][col] = EMPTY;
                        }
                    }
                }

                return null;
            }

            // 评估位置得分
            function evaluatePosition(row, col, player) {
                let score = 0;
                const directions = [
                    [0, 1],   // 水平
                    [1, 0],   // 垂直
                    [1, 1],   // 对角线
                    [1, -1]   // 反对角线
                ];
                
                // 跟踪各种棋型的数量，用于识别复合棋型
                let openThreeCount = 0;
                let openFourCount = 0;
                let fourCount = 0;
                let twoCount = 0;
                let blockedThreeCount = 0;
                
                // 记录每个方向的威胁
                const directionThreats = [];

                for (const [dx, dy] of directions) {
                    // 扩大检查范围到9个位置，更好地识别连续棋型
                    let sequence = '';
                    let dirScore = 0;

                    for (let i = -4; i <= 4; i++) {
                        const r = row + i * dx;
                        const c = col + i * dy;

                        if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) {
                            sequence += 'x'; // 边界
                        } else if (board[r][c] === EMPTY) {
                            sequence += '0';
                        } else if (board[r][c] === player) {
                            sequence += '1';
                        } else {
                            sequence += '2'; // 对手棋子
                        }
                    }

                    // 增强棋型识别的模式和评分
                    const patterns = [
                        { regex: /11111/, score: SCORES.FIVE, type: 'FIVE' }, // 五连
                        
                        // 活四和各种变形
                        { regex: /011110/, score: SCORES.OPEN_FOUR, type: 'OPEN_FOUR' }, // 活四
                        
                        // 各种冲四形态
                        { regex: /011112|211110/, score: SCORES.BLOCKED_FOUR, type: 'BLOCKED_FOUR' }, // 冲四（单边封堵）
                        { regex: /0111010|0101110/, score: SCORES.BLOCKED_FOUR, type: 'BLOCKED_FOUR' }, // 特殊冲四形态
                        { regex: /10111|11011|11101/, score: SCORES.BLOCKED_FOUR, type: 'BLOCKED_FOUR' }, // 跳四
                        { regex: /011101|101110/, score: SCORES.BLOCKED_FOUR, type: 'BLOCKED_FOUR' }, // 新增：另一种特殊冲四形态
                        
                                // 活三和各种变形
                                { regex: /01110/, score: SCORES.OPEN_THREE, type: 'OPEN_THREE' }, // 标准活三
                                { regex: /011010|010110/, score: SCORES.OPEN_THREE * 0.9, type: 'OPEN_THREE' }, // 次级活三形态
                                { regex: /0110100/, score: SCORES.OPEN_THREE * 0.8, type: 'OPEN_THREE' }, // 新增：间隔活三变种
                                
                                // 跳三变种 - 增强对跳三的识别
                                { regex: /010110|011010/, score: SCORES.OPEN_THREE * 0.95, type: 'OPEN_THREE' }, // 跳三形态1: ● _ ● ●
                                { regex: /01101|10110/, score: SCORES.OPEN_THREE * 0.9, type: 'OPEN_THREE' }, // 跳三形态2: ● ● _ ●
                                { regex: /0101010/, score: SCORES.OPEN_THREE * 0.85, type: 'OPEN_THREE' }, // 特殊跳三: ● _ ● _ ●
                                
                                // 眠三变种
                                { regex: /211100|001112/, score: SCORES.BLOCKED_THREE, type: 'BLOCKED_THREE' }, // 眠三(一侧被堵)
                                { regex: /10011|11001/, score: SCORES.BLOCKED_THREE, type: 'BLOCKED_THREE' }, // 眠三(跳型)
                                { regex: /21110|01112/, score: SCORES.BLOCKED_THREE * 0.9, type: 'BLOCKED_THREE' }, // 新增：边缘眠三
                                { regex: /10101/, score: SCORES.BLOCKED_THREE * 0.8, type: 'BLOCKED_THREE' }, // 新增：间隔眠三
                                { regex: /210110|011012/, score: SCORES.BLOCKED_THREE * 0.85, type: 'BLOCKED_THREE' }, // 新增：跳三被堵
                        
                        // 活二变种
                        { regex: /00110|01100/, score: SCORES.TWO, type: 'TWO' }, // 活二
                        { regex: /01010/, score: SCORES.TWO, type: 'TWO' }, // 跳活二
                        { regex: /010010/, score: SCORES.TWO * 0.8, type: 'TWO' }, // 间隔活二
                        
                        // 眠二变种
                        { regex: /211000|000112/, score: SCORES.BLOCKED_TWO, type: 'BLOCKED_TWO' }, // 眠二(一侧被堵)
                        { regex: /210100|001012/, score: SCORES.BLOCKED_TWO, type: 'BLOCKED_TWO' }, // 眠二(跳型)
                        { regex: /21010|01012/, score: SCORES.BLOCKED_TWO * 0.8, type: 'BLOCKED_TWO' }, // 边缘眠二
                        
                        // 活一
                        { regex: /00010|01000/, score: SCORES.ONE, type: 'ONE' } // 活一
                    ];

                    // 设置存储当前方向的威胁类型
                    let directionThreatType = null;

                    for (const pattern of patterns) {
                        if (pattern.regex.test(sequence)) {
                            dirScore = pattern.score;
                            
                            // 跟踪各类型棋型的数量
                            if (pattern.type === 'OPEN_THREE') {
                                openThreeCount++;
                                directionThreatType = 'OPEN_THREE';
                            }
                            if (pattern.type === 'BLOCKED_THREE') {
                                blockedThreeCount++;
                                directionThreatType = 'BLOCKED_THREE';
                            }
                            if (pattern.type === 'OPEN_FOUR') {
                                openFourCount++;
                                directionThreatType = 'OPEN_FOUR';
                            }
                            if (pattern.type === 'BLOCKED_FOUR' || pattern.type === 'OPEN_FOUR') {
                                fourCount++;
                                directionThreatType = 'FOUR';
                            }
                            if (pattern.type === 'TWO') {
                                twoCount++;
                                directionThreatType = 'TWO';
                            }
                            
                            score += dirScore;
                            break;
                        }
                    }
                    
                    // 如果此方向有威胁，记录下来
                    if (directionThreatType) {
                        directionThreats.push({
                            direction: [dx, dy],
                            type: directionThreatType,
                            score: dirScore
                        });
                    }
                }
                
                // 计算多方向威胁加成
                if (directionThreats.length >= 2) {
                    // 多方向威胁加成
                    const threatTypes = new Set(directionThreats.map(t => t.type));
                    
                    // 图中特殊情况：多个方向的活三或眠三，加大权重
                    if (openThreeCount >= 2) {
                        score += SCORES.DOUBLE_THREE;
                        
                        // 三个方向上的活三，几乎必胜
                        if (openThreeCount >= 3) {
                            score += SCORES.TRIPLE_THREE;
                        }
                    } 
                    // 活三加眠三的组合
                    else if (openThreeCount >= 1 && blockedThreeCount >= 1) {
                        score += SCORES.DOUBLE_THREE * 0.7;
                    }
                    
                    // 四三组合，几乎必胜
                    if (openThreeCount >= 1 && fourCount >= 1) {
                        score += SCORES.FOUR_THREE;
                    }
                    
                    // 双活二组合
                    if (twoCount >= 2) {
                        score += SCORES.DOUBLE_TWO;
                    }
                    
                    // 多方向威胁通用加成 (针对图中所示情况)
                    if (threatTypes.size >= 2 && directionThreats.length >= 2) {
                        score += SCORES.MULTI_DIRECTION;
                    }
                }
                
                // 根据棋子的数量动态调整分数
                const totalPieces = board.flat().filter(cell => cell !== EMPTY).length;
                
                // 在残局阶段，更重视进攻
                if (totalPieces > 30) {
                    score *= 1.2;
                } else if (totalPieces < 10) {
                    // 在开局阶段，更注重布局和防守
                    const center = (BOARD_SIZE - 1) / 2;
                    const distanceToCenter = Math.abs(row - center) + Math.abs(col - center);
                    score += (14 - distanceToCenter) * 3; // 中心加分
                }

                return score;
            }

            // 评估整个棋盘
            function evaluateBoard() {
                let score = 0;
                let playerMaxThreat = 0;
                let aiMaxThreat = 0;

                // 评估白棋（AI）的优势
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (board[row][col] === WHITE) {
                            const pieceScore = evaluatePosition(row, col, WHITE);
                            score += pieceScore;
                            aiMaxThreat = Math.max(aiMaxThreat, pieceScore);
                        } else if (board[row][col] === BLACK) {
                            const pieceScore = evaluatePosition(row, col, BLACK);
                            playerMaxThreat = Math.max(playerMaxThreat, pieceScore);
                            
                            // 使用动态权重，对危险棋型增加更高防守权重
                            let defensiveFactor = 2.5; // 提高基础防守权重
                            
                            // 根据威胁级别调整防守权重
                            if (pieceScore >= SCORES.OPEN_THREE) defensiveFactor = 3.2;
                            if (pieceScore >= SCORES.BLOCKED_FOUR) defensiveFactor = 3.8;
                            if (pieceScore >= SCORES.OPEN_FOUR || pieceScore >= SCORES.DOUBLE_THREE) defensiveFactor = 4.5; 
                            if (pieceScore >= SCORES.FOUR_THREE) defensiveFactor = 5.0;
                            
                            score -= pieceScore * defensiveFactor;
                        }
                    }
                }
                
                // 额外战术考量：如果玩家有威胁，提高防守优先级
                if (playerMaxThreat >= SCORES.OPEN_THREE && aiMaxThreat < SCORES.FIVE) {
                    score -= playerMaxThreat * 4; // 更强的防守优先级
                }
                
                // 特别关注对角线威胁
                const diagonalThreat = checkDiagonalThreats(BLACK);
                if (diagonalThreat > 0) {
                    score -= diagonalThreat * 2.5; // 额外的对角线防守权重
                }
                
                // 鼓励进攻性下法，特别是在有优势时
                if (aiMaxThreat > playerMaxThreat && aiMaxThreat >= SCORES.OPEN_THREE) {
                    score += aiMaxThreat * 0.5; // 进攻加成
                }

                return score;
            }

            // 检测对角线威胁的函数
            function checkDiagonalThreats(player) {
                let maxThreat = 0;
                const diagonalDirections = [
                    [1, 1],   // 对角线
                    [1, -1]   // 反对角线
                ];
                
                // 遍历棋盘寻找对角线威胁
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (board[row][col] === player) {
                            // 检查每个对角线方向
                            for (const [dx, dy] of diagonalDirections) {
                                let threatScore = evaluateDiagonalThreat(row, col, dx, dy, player);
                                maxThreat = Math.max(maxThreat, threatScore);
                            }
                        }
                    }
                }
                
                return maxThreat;
            }
            
            // 评估特定方向的对角线威胁
            function evaluateDiagonalThreat(row, col, dx, dy, player) {
                // 计算连续棋子数
                let count = 1;
                let openEnds = 0;
                
                // 正向检查
                for (let i = 1; i < 5; i++) {
                    const r = row + i * dx;
                    const c = col + i * dy;
                    
                    if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) break;
                    
                    if (board[r][c] === player) {
                        count++;
                    } else if (board[r][c] === EMPTY) {
                        openEnds++;
                        break;
                    } else {
                        break;
                    }
                }
                
                // 反向检查
                for (let i = 1; i < 5; i++) {
                    const r = row - i * dx;
                    const c = col - i * dy;
                    
                    if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) break;
                    
                    if (board[r][c] === player) {
                        count++;
                    } else if (board[r][c] === EMPTY) {
                        openEnds++;
                        break;
                    } else {
                        break;
                    }
                }
                
                // 根据连续棋子数和开放端数评估威胁
                if (count >= 4) {
                    return openEnds > 0 ? SCORES.BLOCKED_FOUR * 1.5 : SCORES.BLOCKED_FOUR;
                } else if (count == 3) {
                    return openEnds == 2 ? SCORES.OPEN_THREE * 1.2 : (openEnds == 1 ? SCORES.BLOCKED_THREE * 1.2 : 0);
                } else if (count == 2) {
                    return openEnds == 2 ? SCORES.TWO * 1.2 : (openEnds == 1 ? SCORES.BLOCKED_TWO * 1.2 : 0);
                }
                
                return 0;
            }

            // 重新开始游戏
            function restartGame() {
                board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(EMPTY));
                currentPlayer = BLACK;
                gameOver = false;
                lastMove = null;
                statusElement.textContent = '黑方回合';
                initializeBoard();
                isAITurn = false; // 重置 AI 回合标志
                moveHistory = []; // 清空历史记录
                undoButton.disabled = true; // 禁用悔棋按钮
            }

            // 悔棋功能
            function undoMove() {
                if (gameOver || isAITurn || !canUndo) { // 增加对 canUndo 的检查
                    if (!canUndo) {
                        console.log("请先进行一回合再悔棋"); // 或者显示提示信息给用户
                    }
                    return;
                }

                const stepsToUndo = aiEnabled ? 2 : 1;

                if (moveHistory.length < stepsToUndo) {
                    console.log("没有足够的步数可以悔棋");
                    return;
                }

                for (let i = 0; i < stepsToUndo; i++) {
                    const lastStep = moveHistory.pop();
                    if (lastStep) {
                        board[lastStep.row][lastStep.col] = EMPTY;
                        removePiece(lastStep.row, lastStep.col);
                    }
                }

                // 恢复上上一步的lastMove标记
                if (moveHistory.length > 0) {
                    const previousMove = moveHistory[moveHistory.length - 1];
                    const cell = document.querySelector(`.cell[data-row="${previousMove.row}"][data-col="${previousMove.col}"]`);
                    const piece = cell.querySelector('.piece');
                    if (piece) {
                        piece.classList.add('last-move');
                    }
                    lastMove = [previousMove.row, previousMove.col];
                } else {
                    lastMove = null;
                    // 如果历史记录为空，禁用悔棋按钮
                    updateUndoButtonState(true);
                }

                // 切换回上一个玩家
                currentPlayer = moveHistory.length > 0 ? (moveHistory[moveHistory.length - 1].player === BLACK ? WHITE : BLACK) : BLACK;

                // 如果是AI模式，悔棋后总是轮到黑方（玩家）
                if (aiEnabled) {
                    currentPlayer = BLACK;
                }

                statusElement.textContent = currentPlayer === BLACK ? '黑方回合' : '白方回合';
                gameOver = false; // 悔棋后游戏继续
                thinkingIndicator.style.display = 'none'; // 隐藏思考指示器
                canUndo = false; // 悔棋后禁止连续悔棋
                updateUndoButtonState(true); // 悔棋后立即禁用按钮并显示锁图标
            }


            // 切换AI
            function toggleAI() {
                aiEnabled = !aiEnabled;
                aiToggleButton.textContent = `AI对战: ${aiEnabled ? '开启' : '关闭'}`;

                // 如果是关闭AI，且有Web Worker在运行，则终止Worker
                if (!aiEnabled && aiWorker) {
                    aiWorker.terminate();
                    aiWorker = null;
                }

                // 如果现在是AI回合且AI刚被开启
                if (aiEnabled && currentPlayer === WHITE && !gameOver) {
                    // 设置 AI 回合标志
                    isAITurn = true;

                    // 显示思考指示器
                    thinkingIndicator.style.display = 'inline-block';
                    let delay;
                    switch(difficulty) {
                        case 'easy':
                            delay = 200 + Math.random() * 600; // 0.2-0.8秒
                            break;
                        case 'medium':
                            delay = 400 + Math.random() * 800; // 0.4-1.2秒
                            break;
                        case 'hard':
                            delay = 800 + Math.random() * 1000; // 0.8-1.8秒
                            break;
                        case 'insane':
                            delay = 200 + Math.random() * 300; // 降低随机延迟，Worker已经在后台处理
                            break;
                        default:
                            delay = 400 + Math.random() * 800;
                    }

                    setTimeout(async () => {
                        try {
                            // 获取AI下棋位置（与handleCellClick中保持一致的异步处理方式）
                            let aiMove;
                            if (difficulty === 'insane') {
                                // 疯狂难度使用Web Worker异步计算
                                aiMove = await findInsaneMove();
                            } else {
                                // 其他难度仍使用同步方式
                                aiMove = findBestMove();
                            }
                            
                            const [aiRow, aiCol] = aiMove;
                            makeMove(aiRow, aiCol, WHITE);

                            // 播放落子音效
                            playClickSound();

                            // 隐藏思考指示器
                            thinkingIndicator.style.display = 'none';

                            if (checkWin(aiRow, aiCol, WHITE)) {
                                gameOver = true;
                                statusElement.textContent = 'AI(白方)获胜!';
                                updateUndoButtonState(true); // 游戏结束，禁用悔棋

                                // 移除AI回合标志
                                isAITurn = false;
                                return;
                            }

                            currentPlayer = BLACK;
                            statusElement.textContent = '黑方回合';
                        } catch (error) {
                            console.error('AI决策出错:', error);
                            // 出错时恢复游戏状态
                            thinkingIndicator.style.display = 'none';
                            currentPlayer = BLACK;
                            statusElement.textContent = '黑方回合';
                        } finally {
                            // 无论如何，确保AI回合标志被重置
                            isAITurn = false;
                            updateUndoButtonState(false); // 启用悔棋按钮
                        }
                    }, delay);
                }
                // 如果关闭AI，且当前是白方回合，确保悔棋按钮可用
                if (!aiEnabled && currentPlayer === WHITE) {
                    updateUndoButtonState(moveHistory.length === 0);
                }
            }

            // 更改难度
            function changeDifficulty() {
                const oldDifficulty = difficulty;
                difficulty = difficultySelect.value;
                
                // 如果从非疯狂切换到疯狂或从疯狂切换到非疯狂，且已有Worker，则终止并创建新Worker
                if ((oldDifficulty === 'insane' || difficulty === 'insane') && aiWorker) {
                    aiWorker.terminate();
                    aiWorker = null;
                }
            }
            
            // 终止Web Worker的清理函数（在页面卸载时执行）
            window.addEventListener('beforeunload', function() {
                if (aiWorker) {
                    aiWorker.terminate();
                    aiWorker = null;
                }
            });
            
            // 更新重新开始游戏函数，清理Worker
            function restartGame() {
                // 终止可能存在的Worker
                if (aiWorker) {
                    aiWorker.terminate();
                    aiWorker = null;
                }
                
                board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(EMPTY));
                currentPlayer = BLACK;
                gameOver = false;
                lastMove = null;
                statusElement.textContent = '黑方回合';
                initializeBoard();
                isAITurn = false; // 重置 AI 回合标志
                canUndo = true; // 重置悔棋状态
                moveHistory = []; // 清空历史记录
                updateUndoButtonState(true); // 禁用悔棋按钮
            }

            // 事件监听
            restartButton.addEventListener('click', restartGame);
            aiToggleButton.addEventListener('click', toggleAI);
            difficultySelect.addEventListener('change', changeDifficulty);
            undoButton.addEventListener('click', undoMove); // 添加悔棋按钮监听

            // 更新悔棋按钮状态的函数
            function updateUndoButtonState(disabled) {
                undoButton.disabled = disabled;
                if (disabled) {
                    undoButton.classList.add('locked');
                } else {
                    undoButton.classList.remove('locked');
                }
            }

            // 初始化游戏
            initializeBoard();
            updateUndoButtonState(true); // 初始禁用悔棋按钮
        });
    </script>
</body>

</html>
